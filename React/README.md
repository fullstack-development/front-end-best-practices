# React

1. [Именование папок и файлов](#1)
2. [Компоненты](#2)
3. [Пропсы](#3)
4. [SVG](#4)
5. [Экспорт](#5)
6. [Переменные окружения](#6)
7. [Работа с API](#7)
8. [Общие принципы работы со стейт менеджерами](#8)
9. [Оптимизация](#9)
10. [Общее](#10)


## Интро

В этом топике собраны best practices, как напрямую касающиеся React, так и те, которые так или иначе затрагивают будни frontend-разработчика. Помимо самих best practices, в этом топике также содержатся правила, относящиеся больше к стайлгайду, нежели к лучшим практикам. Таким образом хотелось бы прийти к большему однообразию в написании кода на разных проектах, что упростит переход разработчика с одного проекта на другой, поскольку при чтении и анализе кода/структуры проекта будет прилагаться меньше когнитивных усилий. Также это может уменьшить количество холиваров по поводу разных стилей написания кода (но это неточно :). Следует не забывать, что не стоит впадать в крайности. Иногда какое-то правило может только мешать и делать хуже, так как всех кейсов не опишешь.

Так же не забываем про топик [JS](../JS/README.md), в котором много полезных правил вне зависимости от фреймворков.

<a name="1"></a>

## Именование папок и файлов

Прежде всего отталкивайтесь от договорённостей на проекте. Договоритесь с коллегами о стиле именования заранее или придерживайтесь уже существующих правил на проекте. 

Вот какой стиль используем мы:

- Папка с React компонентом именуется в PascalCase, именем самого компонента.

- Файл css со стилями для компонента, если имеется, именуется в PascalCase, именем самого компонента. Файл со стилями лежит рядом со своим компонентом, на одном уровне вложенности.

- Папки и файлы с функциями, утилитами, константами, типами и прочее, именуются в camelCase.

- Файлы css с глобальными стилями, если имеются, именуются в kebab-case

- Папки и файлы для страниц и ассетов именуются в kebab-case

- Файл с самим React компонентом можно именовать по разному. Кому-то нравится PascalCase с именем самого компонента, кому-то `index.tsx`. Кто-то именует все компоненты `Component.tsx`, стили рядом `styles.css` и добавляет `index.ts` для реэкспорта. Мы не смогли прийти к единому мнению, так что решать вам. Главное, что бы в проекте везде было одинаково.

<a name="2"></a>

## Компоненты

<a name="2.1"></a>

- [2.1](#2.1) Именование переменной и функции при вызове `useState` должно быть одинаковым, только к функции прибавляется слово `set`.

  Плохо:
  ```typescript
  const [isModalOpen, openModal] = useState();
  ```
  Хорошо:
  ```typescript
  const [isModalOpen, setIsModalOpen] = useState();
  ```

<a name="2.2"></a>

- [2.2](#2.2) Разделяйте хуки `useEffect` для разных задач - [React docs](https://ru.reactjs.org/docs/hooks-effect.html#tip-use-multiple-effects-to-separate-concerns) 

<a name="2.3"></a>

- [2.3](#2.3) Помещайте вызовы `useEffect` в самый низ, перед `return` (есть исключение, описанное в конце [2.4](#2.4)).

<a name="2.4"></a>

- [2.4](#2.4) Не создавайте лишние JSX переменные. В подавляющем большинстве случаев их содержимое можно вставить внутрь оператора `return`.

  Плохо:
  ```typescript
  const MyComponent: FC<Props> = ({ array, condition }) => {
    const list = array.map((item) => <li key={item}>{item}</li>);

    const conditionalRender = condition ? <div /> : <section />;

    return (
      <div>
        <ul>{list}</ul>
        {conditionalRender}
      </div>
    );
  };
  ```
  Хорошо:
  ```typescript
  const MyComponent: FC<Props> = ({ array, condition }) => {
    return (
      <div>
        <ul>
          {array.map((item) => (
            <li key={item}>{item}</li>
          ))}
        </ul>
        {condition ? <div /> : <section />}
      </div>
    );
  };
  ```
  В редких случаях, когда ваш рендер зависит от сложного условия или цепочки условий, что приводит к плохой читабельности или вложенным условным операторам `?`, лучше вынести такой код в функцию, в которой описать логику c использованием `if`. И затем вызвыть эту функцию в `return`. Такие функции должны быть в самом низу перед `return`, ниже чем вызовы `useEffect` (исключение для [2.3](#2.3)).

<a name="2.5"></a>

- [2.5](#2.5) Не объявляйте константы и функции-хелперы внутри компонента. Код компонента выполняется на каждом рендере, следовательно это лишние вычисления по созданию новых переменных на каждом рендере. Выносите их за пределы компонента, создавая файлы (напр. `constants`/`helpers`/`utils`/`helperName`) рядом с самим компонентом, если они специфичны для него или в более общее место (обычно это папка `shared`), если они могут использоваться где-то ещё.

  Плохо:
  ```typescript
  const MyComponent: FC<Props> = ({ ... }) => {
    const DAYS_IN_WEEK = 7;

    const calculateSomeValue = () => { ... };

    return ( ... );
  };
  ```
  Хорошо:
  ```typescript
  // Константы здесь рядом с компонентом для примера, их надо вынести в отдельные файлы.
  const DAYS_IN_WEEK = 7;

  const calculateSomeValue = () => { ... };

  const MyComponent: FC<Props> = ({ ... }) => {
    return ( ... );
  };
  ```

<a name="2.6"></a>

- [2.6](#2.6) Не забываем про хорошие практики компонентного подхода, описанные в разделе CSS [4.4-4.6](https://github.com/fullstack-development/front-end-best-practices/tree/master/CSS#4.4)

<a name="3"></a>

## Пропсы

<a name="3.1"></a>

- [3.1](#3.1) Пропсы компонента объявлять перед компонентом в том же файле. Это позволит не переключаться между файлами при чтении и беглом просмотре компонента. 

<a name="3.2"></a>

- [3.2](#3.2) Именовать пропсы компонента словом `Props`. Более подробное имя для пропсов не требуется, из контекста и так понятно, что это пропсы для текущего компонента.

<a name="3.3"></a>

- [3.3](#3.3) Если ваш компонент предполагает обязательное использование пропа `children`, явно объявите его в `Props` и сделайте обязательным. Если `children` необязательный, можно воспользоваться вспомогательным встроенным типом `PropsWithChildren<Props>`.

<a name="3.4"></a>

- [3.4](#3.4) Не экспортируйте пропсы компонента без причины. Во первых это засоряет подсказки редактора кода, во вторых неясно, эти пропсы действительно где-то используются или нет. Экспортируйте только если они используются где-то ещё. При экспорте пропсам следует дать более осмысленное имя, добавив название компонента в начало: 
  ```typescript
  export { type Props as MyComponentProps };
  ```
  Примечание: правило применимо, если вы пропсы объявляете в том же файле, что и сам компонент.

<a name="3.5"></a>

- [3.5](#3.5) Порядок указания пропсов должен быть следующим:

  1. Все обязательные пропы-React компоненты

  2. Все необязательные пропы-React компоненты

  3. Все обязательные значения.

  4. Все необязательные значения.

  5. Все обязательные функции.

  6. Все необязательные функции.

  Все необязательные пропсы-значения должны иметь значение по умолчанию.
  
  Если в проекте нет других соглашений, для типов функций используется синтаксис `func(): type`, а не `func: () => type`.

  Пример:
  ```tsx
  type Props = {
    Content: FC;
    Icon?: FC;
    size: 'm' | 'l';
    color?: 'primary' | 'secondary' | 'inherit';
    useIsActive(): boolean;
    onClick?(): void;
  }

  const MyComponent: FC<Props> = ({ Content, Icon, size, color = 'inherit', useIsActive, onClick }) => {...}
  ```


<a name="3.6"></a>

- [3.6](#3.6) Пропсы компонента, относящиеся к обработке событий, должны именоваться по шаблону `onEventName`, где `EventName` — имя обрабатываемого события.

<a name="4"></a>

## SVG

<a name="4.1"></a>

- [4.1](#4.1) Для одноцветных svg-иконок задавайте свойство `fill`|`stroke` в значение `currentColor`. Так можно будет по умолчанию получать цвет родителя и менять его из CSS

<a name="4.2"></a>

- [4.2](#4.2) Во многих фреймворках встроен SVGR, который позволяет подключать svg-файлы как реакт-компоненты. Проблема в том, что у такого компонента напрочь отсутствует типизация, ему можно передать любые пропсы. Решить эту проблему можно следующим образом: 
  1. создайте файл `global.d.ts.` со следующим содержимым: 
      ```ts
        declare module '*.svg' {
        import * as React from 'react';

        export const ReactComponent: React.FunctionComponent<
          React.SVGProps<SVGSVGElement> & { title?: string }
        >;

        const src: string;
        export default src;
      }
      ```   
  2. Добавьте путь к файлу в массив `include` в вашем `tsconfig.json` (в примере файл находится в корне проекта): 
  ![image](https://user-images.githubusercontent.com/90761929/222449468-db502f0b-1997-445a-91b9-e9ee8e96d8ee.png)
  3. Далее при импорте svg - файла вам надо будет писать:
      ```ts
        import { ReactComponent as DisableIcon } from './icons/disable.svg';
        import { ReactComponent as EnableIcon } from './icons/enable.svg';
      ```   
      Но эту запись можно улучшить. Создайте файл `index.ts` в папке `icons` и сделайте там реэкспорт ваших svg-файлов:
      ```ts
        export { ReactComponent as DisableIcon } from './icons/disable.svg';
        export { ReactComponent as EnableIcon } from './icons/enable.svg';
      ```   
      Теперь у вас будет красивый импорт и типизированные svg: 
      ```ts
        import { DisableIcon, EnableIcon } from './icons';
      ```   


<a name="5"></a>

## Экспорт

<a name="5.1"></a>

- [5.1](#5.1) Именованный экспорт предпочтительней дефолтного. Именованный экспорт заставляет нас использовать правильное имя при импорте, исключая возможность написания любого имени или банально опечатки. Особенно неприятно, если одна и та же сущность в разных местах импортируется с разными именами. С именованными импортами за этим не нужно следить.

<a name="5.2"></a>

- [5.2](#5.2) Используйте реэкспорт. Например в корне папки `components` создайте `index.ts` файл и экспортируйте в нём все необходимые компоненты:
  ```typescript
  // src/components/index.ts

  // Если вы используйете именованный экспорт
  export { MyComponent } from './MyComponent';
  // Если вы используете дефолтный экспорт
  export { default as MyComponent} from './MyComponent';
  ```
  Это позволит при импорте делать запись следующего вида:
  ```typescript
  // Было
  import { MyComponent1 } from 'shared/components/MyComponent1';
  import { MyComponent2 } from 'shared/components/MyComponent2';
  import { MyComponent3 } from 'shared/components/MyComponent3';
  // Стало
  import { MyComponent1, MyComponent2, MyComponent3 } from 'shared/components';
  ```
  Во первых в большинстве случаев это сокращает запись импортов. Во вторых так проще следить за [порядком импортов](../JS/README.md#1.17), так как у вас теперь меньше вложенности. В третьих вы явно декларируете, что можно импортировать из той или иной папки. У вас появляется "точка входа". Не всегда все компоненты, утилиты и т.д. должны экспортироваться наружу. Часть из них может быть предназначена для внутреннего пользования. Типичные случаи для реэкспорта: папки `components`, `icons`, `utils`, `hooks`, `features/featureName`, и т.д.
  
  Если вам нужно просто прокинуть реэкспорт из вложенной папки (со своим `index.ts`) на уровень выше, можно воспользоваться синтаксисом:
  ```typescript
  export * from './folderName';
  ```

<a name="6"></a>

## Переменные окружения

<a name="6.1"></a>

- [6.1](#6.1) Если в вашем проекте используются переменные окружения, например файл `.env`, создайте файл `.env.example`, который попадёт в индексацию git. Перечислите в нём все переменные окружения, но без их значений. Так будет понятно, какое ожидается содержимое `.env` файла для работы проекта. Для большей ясности можно указать тип переменной (не забывая, что все переменные окружения изначально строки), например: 
  ```
  NEXT_PUBLIC_API_URL=string
  NEXT_PUBLIC_IS_TESTNET=boolean
  NEXT_PUBLIC_TRANSACTION_FEE=number
  ```

- [6.2](#6.2) Вынесите переменные окружения в отдельный объект, например:
  ```typescript
  // shared/constants/environment.ts
  export const environment = {
    apiUrl: process.env.NEXT_PUBLIC_API_URL,
    isTestnet: process.env.NEXT_PUBLIC_IS_TESTNET,
    transactionFee: process.env.NEXT_PUBLIC_TRANSACTION_FEE
  };
  ```
  По умолчанию `process.env` никак не типизирован и даёт возможность обратиться к чему угодно. Это неудобно при обращении к переменным окружения. Приходится либо писать переменную по памяти (где легко ошибиться), либо копировать - вставить. Обращаясь к переменным окружения только в одном месте, вы сужаете все потенциальные ошибки до этого места. Там же можно выполнить предварительную обработку при необходимости, сделать приведение типа один раз вместо того, что бы делать это везде, где используется переменная. Так же запись вида `environment.apiUrl` куда приятнее, чем `process.env.NEXT_PUBLIC_API_URL`. 

  В качестве альтернативы, если вы не хотите создавать отдельный объект, можно [типизировать](https://stackoverflow.com/questions/45194598/using-process-env-in-typescript) сам `process.env`.

<a name="7"></a>

## Работа с API

<a name="7.1"></a>

- [7.1](#7.1) Поместите функции по работе с API в папку `api`, структурируйте её. Будь-то обычный `fetch` или использование `axios` с его конфигом, интерсепторами, пр. Там же могут лежать и типы ответов на запросы. Затем вызывайте эти функции в стейт менеджере, компонентах, где либо ещё. Так у вас в одном месте будет вся работа с api. Вот пример одной из возможных структур с использованием `axios`:
  ```
  api
  ├── controllers
  │   ├── feedback             
  │   │   ├── converters    # папка с конвертерами для данных запросов
  │   │   ├── controller.ts # содержит функции get, post, delete для /feedback   
  │   │   ├── index.ts      # реэкспорт
  │   │   ├── types.ts      # типы для данных запросов     
  ├── config.ts     # конфиг axios
  ├── core.ts       # интерсепторы axios
  ├── helpers.ts 
  ``` 
  Исключения: использование библиотек, предлагающих свою структуру организации работы с API. Например таких как `rtk-query`.

<a name="8"></a>

## Общие принципы работы со стейт менеджерами

Если у вас в проекте **нет явной архитектуры**:

<a name="8.1"></a>

- [8.1](#8.1)  Cтарайтесь разделять стейт по функционалу. Не пихайте всё в один стейт. Если вы используете стейт менеджер для запросов к API, возможно вам поможет структура сущностей бэкенда - users, rooms, orders, auth.

<a name="8.2"></a>

- [8.2](#8.2) Если вы используете стейт менеджер для запросов к API, делайте все запросы через стейт менеджер. Даже если они никак не взаимодействуют со стейтом (напр. это может быть POST-запрос, который ничего не возвращает). Нужно это для однообразия, что бы не было так, что часть компонентов делают запросы напрямую, а часть через диспатч. 

<a name="9"></a>

## Оптимизация

- В интернете есть множество материалов про [преждевременную оптимизацию](https://habr.com/ru/companies/ruvds/articles/465809/) и чем она вредна. Помните об этом. 
- Если ваш код работает некорректно без оптимизации, а с оптимизацией проблема уходит, то вам стоит в первую очередь устранить проблему, и только потом оптимизировать. 
- Мы же хотим поговорить про особенности рендеринга React приложений и частые кейсы, из-за которых ваше приложение может начать тормозить. У нас есть крайне полезный [топик](./Optimization.md), посвящённый некоторым оптимизациям при разработке React-приложений.

<a name="10"></a>

## Общее

<a name="10.1"></a>

- [10.1](#10.1) Не создавайте не нужных `.tsx` файлов. Если в таком файле нет JSX кода, он должен иметь расширение `.ts`.
