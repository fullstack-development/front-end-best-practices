1. **Соглашение об именованиях:**
    1. Блок, элемент — всегда имя существительное (noun);

    1. Модифатор — должен удовлетворять свойстам [модификатора из английского языка](https://en.wikipedia.org/wiki/Grammatical_modifier). Всегда `adjective` или `adjectival phrase`;

        > Таким образом, фразы на английском языке  `"$BLOCK_NAME [is] $MODIFIER_NAME"`, `"$ELEMENT_NAME [is] $MODIFIER_NAME"` или `"$MODIFIER_NAME $BLOCK_NAME"`, `"$MODIFIER_NAME $ELEMENT_NAME"` должны быть синтаксически корректными словосочетаниями.  
        > Примеры <i>корректных имён:</i>
        > - `input_selected` — `selected input` — выделенный инпут или `input is selected` — инпут выделен;
        > - `header_large` — `large header` — большой заголовок;    
        > Примеры <i>НЕкорректных имён:</i>
        > - `form__`***save***`_small`, для элемента save (который, например, вешается на кнопку) — `small save` — маленький сохранить, `save small` — сохранить маленький. Правильно будет употребить noun вместо `verb`  и переименовать элемент в ***`save-button;`*** `small save-button` — маленькая кнопка сохранения;
        > - `input_`***focus*** — `input focus` — инпут сфокусировать или `input is focus` — инпут это фокус. Правильно будет употребить `adjective` вместо `noun/verb` и переименовать модификатор в `focused; input_`***focused*** — `focused input` — сфокусированный инпут;
        > - `row_`***error*** — `row error` — ошибка строки или `row is error` — строка это ошибка; Правильно будет употребить `adjectival phrase` вместо `noun `и переименовать модификатор в `with-error;` `row_`***with***`-error` — `row with  error` — строка с ошибкой;

    > Обоснование: мы сможем всегда однозначно и без лишних затрат энергии  истолковать сущность элемента вёрстки и накладываемые на него свойства.
    
2. **Верстаем всегда по БЭМу, архитектура верстки должна быть компонентной**;

3. **Каждый компонент - отдельный блок из методологии БЭМ**;

4. **Каждый компонент должен быть иметь только явные зависимости, должен быть самодостаточен**;
    >Все зависимости явно делать импортируя в начале компонента и вставляя в нужное место верстки
    > Самодостаточность говорит о том, что каждый компонент должен внутри себя содержать все необходимое - всю верстку, все стили и все js-скрипты

    > Ничего лишнего в компоненте быть не должно:
    > * Не должно быть определения других блоков внутри этого блока;
    > * Не должно быть стилей, которые бы влияли на другие блоки любым способом;
    > * Не должно быть глобальных стилей (например, на все теги `span`);
    > * компонента не должен влиять на `DOM` другого компонента (менять верстку крайне запрещено);

5. **Кастомизировать компоненты только через модификаторы, никаких примесей**;
    > Почти в любом проекте возникает необходимость кастомизировать блоки. Например, есть вёрстка из 20 страниц. На 15 из этих страниц встречается хэдер, причём у 10 из них хэдер синего цвета, на трёх — серый, и на двух — прозрачный. Это значит, что компонента футер должна быть кастомизируемая, и осуществляются подобного рода кастомизации через добавление модификаторов к блоку, а не путём передачи отдельных классов со стилями.  
    > Предположим, что на фоне у промо страницы есть видео, и по дизайну нам нужно сделать прозрачный футер с светлым шрифтом (по умолчанию — тёмный).

    > Плохо:
    > ```
    >    .promo-page
    >      +header({classname: 'promo-page__header'})
    >  ```

    > Хорошо:
    > ```
    >    promo-page
    >      +header({theme: 'transparent', font: 'light'})
    >  ```
    > При правильном подходе, естественно, надо будет научиться принимать эти два параметра, добавлять самому модификаторы к нужным классам и в CSS компонента прописывать правила для этих модификаторов.

    > Это правило внедрено после болезненного опыта поддержки проекта средней сложности, и вот какие шишки набиты, используя примеси:
    > * Нарушается инкапсулияци - использование внешних стилей внутри компоненты ведёт к проблемам в сопровождении в дальнейшем. Дело в том, что стили компоненты являются её составной частью, и не должны влиять на то, что её окружает. Так же справедливо обратное — внешние стили не должны влиять на компоненту. Иными словами, компонента должны быть самодостаточна. Прибегая к использованию внешних стилей мы создаём зависимость между двумя стилями - внешним, и внутренним. Каждому из стилей нужно знать, из чего состоит другой, чтобы глобальный стиль не поломал стиль компоненты. Это и есть нарушение инкапсуляции;
    > * Если компонента используется на 20 разных страницах, то после изменения одного свойства в самом компоненте придется пройти по всем 20 страницам вручную и проверить что ничего не сломалось, потому что неизвестно какие могут быть стили навешаны в местах использования через кастомные классы и надо самому проверить все комбинации;
    > * Примесь обычно вешается только на верхний уровень компонента, но иногда надо кастомизировать что нибудь внутреннее, тогда получается, надо уже две примеси передавать и принимать в компоненте, одна примесь для свойств всего блока, второй для какого-то элемента, а когда понадобится еще другой элемент кастомизировать, придется добавить третью примесь :) ;
    > * Не получится четко составить список всех возможных состояний компоненты, а при подходе с модификаторами мы явно видим все возможные параметры на входе, и когда их число будет зашкаливать, можем пнуть дизайнера, что он слишком расфантазировался и пора бы переходить к единому стайлгайду;
