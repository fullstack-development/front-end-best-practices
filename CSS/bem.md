1. **Именование БЭМ-сущностей должно следовать следующим ограничениям:**
    * блок, элемент — всегда имя существительное (noun);

    * модификатор — должен удовлетворять свойствам [модификатора из английского языка](https://en.wikipedia.org/wiki/Grammatical_modifier). Всегда `adjective` или `adjectival phrase`.

        > Таким образом, фразы на английском языке `"$BLOCK_NAME [is] $MODIFIER_NAME"`, `"$ELEMENT_NAME [is] $MODIFIER_NAME"` или `"$MODIFIER_NAME $BLOCK_NAME"`, `"$MODIFIER_NAME $ELEMENT_NAME"`, `"$ELEMENT_NAME WITH $MODIFIER_NAME $MODIFIER_KEY"` должны быть синтаксически корректными словосочетаниями.

        > Примеры <i>корректных имён:</i>
        > - `input_selected` — `selected input` — выделенный инпут или `input is selected` — инпут выделен;
        > - `header_size_large` — `header with large size` — заголовок с большим размером.


        > Примеры <i>НЕкорректных имён:</i>
        > - `form__`***save***`_small`, для элемента save (который, например, вешается на кнопку) — `small save` — маленький сохранить, `save small` — сохранить маленький. Правильно будет употребить noun вместо `verb` и переименовать элемент в ***`save-button;`*** `small save-button` — маленькая кнопка сохранения;
        > - `input_`***focus*** — `input focus` — инпут сфокусировать или `input is focus` — инпут это фокус. Правильно будет употребить `adjective` вместо `noun/verb` и переименовать модификатор в `focused; input_`***focused*** — `focused input` — сфокусированный инпут;
        > - `row_`***error*** — `row error` — ошибка строки или `row is error` — строка это ошибка; Правильно будет употребить `adjectival phrase` вместо `noun` и переименовать модификатор в `with-error;` `row_`***with***`-error` — `row with error` — строка с ошибкой.

    > Обоснование: мы сможем всегда однозначно и без лишних затрат энергии истолковать сущность элемента вёрстки и накладываемые на него свойства.

2. **Верстаем всегда по БЭМу, архитектура верстки должна быть компонентной**.
    >Каждый блок должен лежать в своей папке.
    >Папки блоков нельзя вкладывать друг в друга.

3. **Каждый компонент — отдельный блок из методологии БЭМ**.

4. **Каждый компонент должен быть иметь только явные зависимости, должен быть самодостаточен**.
    >Все зависимости делать явно, импортируя в начале компонента и вставляя в нужное место верстки.
    > Самодостаточность говорит о том, что каждый компонент должен внутри себя содержать все необходимое — всю верстку, все стили и все js-скрипты.

    > Ничего лишнего в компоненте быть не должно:
    > * Не должно быть определения других блоков внутри этого блока;
    > * Не должно быть стилей, которые бы влияли на другие блоки любым способом;
    > * Не должно быть глобальных стилей (например, на все теги `span`);
    > * Компонент не должен влиять на `DOM` другого компонента (менять верстку крайне запрещено);

5. **Кастомизировать компоненты только через модификаторы, никаких примесей**.
    > Почти в любом проекте возникает необходимость кастомизировать блоки. Например, есть вёрстка из 20 страниц. На 15 из этих страниц встречается хэдер, причём у 10 из них хэдер синего цвета, на трёх — серый, и на двух — прозрачный. Это значит, что компонент хэдер должен быть кастомизируемым, и осуществляются подобного рода кастомизации через добавление модификаторов к блоку, а не путём передачи отдельных классов со стилями.
    > Предположим, что на фоне у промо страницы есть видео, и по дизайну нам нужно сделать прозрачный хэдер со светлым шрифтом (по умолчанию — тёмный).

    > Плохо:
    > ```
    >    .promo-page
    >      +header({ classname: 'promo-page__header' })
    >  ```

    > Хорошо:
    > ```
    >    promo-page
    >      +header({ theme: 'transparent', font: 'light' })
    >  ```
    > При правильном подходе, естественно, надо будет научиться принимать эти два параметра, добавлять самому модификаторы к нужным классам и в CSS компонента прописывать правила для этих модификаторов.

    > Это правило внедрено после болезненного опыта поддержки проекта средней сложности, и вот какие шишки набиты с использованием примесей:
    > * Нарушается инкапсуляции — использование внешних стилей внутри компоненты ведёт к проблемам в сопровождении в дальнейшем. Дело в том, что стили компоненты являются её составной частью и не должны влиять на то, что её окружает. Также справедливо обратное — внешние стили не должны влиять на компоненту. Иными словами, компонента должна быть самодостаточна. Прибегая к использованию внешних стилей, мы создаём зависимость между двумя стилями — внешним и внутренним. Каждому из стилей нужно знать, из чего состоит другой, чтобы глобальный стиль не поломал стиль компоненты. Это и есть нарушение инкапсуляции;
    > * Если компонента используется на 20 разных страницах, то после изменения одного свойства в самом компоненте придется пройти по всем 20 страницам вручную и проверить, что ничего не сломалось, потому что неизвестно, какие могут быть стили навешаны в местах использования через кастомные классы, и надо самому проверить все комбинации;
    > * Примесь обычно вешается только на верхний уровень компонента, но иногда надо кастомизировать что-нибудь внутреннее, тогда получается, надо уже две примеси передавать и принимать в компоненте, одна примесь — для свойств всего блока, вторая — для какого-то элемента, а когда понадобится еще другой элемент кастомизировать, придется добавить третью примесь :) ;
    > * Не получится четко составить список всех возможных состояний компоненты, а при подходе с модификаторами мы явно видим все возможные параметры на входе, и когда их число будет зашкаливать, можем пнуть дизайнера, что он слишком расфантазировался и пора бы переходить к единому стайлгайду;

6. **Для позиционирования блока в родительском контейнере тоже не надо использовать миксы — решается данная проблема путем добавления специальных контейнеров**.
    > Допустим, есть родительский блок, в нем — дочерний блок, который нам и необходимо спозиционировать. Для позиционирования внутреннего блока создаем в родительском элемент-обертку и просто задаем свойства (*margin, padding, position* etc) этому контейнеру. Таким образом, позиционирование блока у нас находится в файле родительского блока и никак не влияет на стили самого блока.

    > Данный способ позволяет, не используя миксы, спозиционировать дочерний блок.

    > Например, в хэдере у нас находится обычная голубая кнопка, но именно тут, в шапке, она должна иметь отступ с левой стороны, для этого мы добавим `div.header__button`:
    > ```
    >    div.header
    >      div.header__button
    >        +button({ color:blue })
    > ```

    > А в стили хэдера просто добавим:
    > ```
    >    .header__button {
    >      margin-left: 3rem;
    >    }
    > ```
